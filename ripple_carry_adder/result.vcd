$date
  Tue Nov 21 14:47:08 2017
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$var reg 4 ! switch_a[3:0] $end
$var reg 4 " switch_b[3:0] $end
$var reg 4 # indicator[3:0] $end
$var reg 1 $ carry $end
$scope module carry_ripple_adder_u $end
$var reg 4 % a[3:0] $end
$var reg 4 & b[3:0] $end
$var reg 1 ' cin $end
$var reg 4 ( sum[3:0] $end
$var reg 1 ) cout $end
$var reg 4 * carry_internal[3:0] $end
$scope module (0) $end
$scope module B1 $end
$scope module fa_0 $end
$var reg 1 + x $end
$var reg 1 , y $end
$var reg 1 - cin $end
$var reg 1 . cout $end
$var reg 1 / sum $end
$var reg 1 0 sum_0 $end
$upscope $end
$upscope $end
$upscope $end
$scope module (1) $end
$scope module B1 $end
$scope module fa_i $end
$var reg 1 1 x $end
$var reg 1 2 y $end
$var reg 1 3 cin $end
$var reg 1 4 cout $end
$var reg 1 5 sum $end
$var reg 1 6 sum_0 $end
$upscope $end
$upscope $end
$upscope $end
$scope module (2) $end
$scope module B1 $end
$scope module fa_i $end
$var reg 1 7 x $end
$var reg 1 8 y $end
$var reg 1 9 cin $end
$var reg 1 : cout $end
$var reg 1 ; sum $end
$var reg 1 < sum_0 $end
$upscope $end
$upscope $end
$upscope $end
$scope module (3) $end
$scope module B1 $end
$scope module fa_i $end
$var reg 1 = x $end
$var reg 1 > y $end
$var reg 1 ? cin $end
$var reg 1 @ cout $end
$var reg 1 A sum $end
$var reg 1 B sum_0 $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
b0010 !
b0011 "
b0101 #
0$
b0010 %
b0011 &
0'
b0101 (
0)
b0010 *
0+
1,
0-
0.
1/
10
11
12
03
14
05
06
07
08
19
0:
1;
0<
0=
0>
0?
0@
0A
0B
#1000000
b0110 !
b1011 "
b0001 #
1$
b0110 %
b1011 &
b0001 (
1)
b1110 *
17
1:
0;
1<
1>
1?
1@
0A
1B
#2000000
b0010 !
b1111 "
b0010 %
b1111 &
07
18
#3000000
